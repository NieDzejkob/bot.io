use crate::ast::*;
use num_bigint::BigUint;

grammar;

Boxed<T>: Box<T> = {
    T => Box::new(<>)
};

Spanned<T>: Span<T> = {
    <l:@L> <v:T> <r:@R> => Span(v, (l, r))
};

BSpanned<T>: BSpan<T> = Boxed<Spanned<T>>;

Tier<Op, NextTier>: Expr<'input> = {
    BSpanned<Tier<Op, NextTier>> Spanned<Op> BSpanned<NextTier> => Expr::BinOp(<>),
    NextTier
};

pub Command: Command<'input> = {
    Expr => Command::Expr(<>),
    Pred => Command::Pred(<>),
};

Pred: Pred<'input> = {
    Expr Cmp Expr => Pred::Cmp(<>)
};

Cmp: Cmp = {
    "=" => Cmp::Eq,
    "<" => Cmp::Lt,
    "<=" => Cmp::Le,
    ">" => Cmp::Gt,
    ">=" => Cmp::Ge,
};

pub Expr = {
    Product,
    "if" <BSpanned<Pred>> "then" <BSpanned<Expr>> "else" <BSpanned<Expr>> => Expr::If(<>),
};

Product = Tier<ProductOp, Factor>;
Factor = Tier<FactorOp, Neg>;

ProductOp: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
};

FactorOp: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
};

Neg: Expr<'input> = {
    "-" <BSpanned<Term>> => Expr::Neg(<>),
    Term,
};

Term: Expr<'input> = {
    "(" <Expr> ")",
    Spanned<Num> => Expr::Num(<>),
    Spanned<Ident> => Expr::Ident(<>),
    <id:Spanned<Ident>> "(" <mut params:(<Spanned<Expr>> ",")*> <last:Spanned<Expr>> ")" => {
        params.push(last);
        Expr::Func(id, params)
    }
};

Num: BigUint = r"0|[1-9][0-9]*" => <>.parse().unwrap();
Ident: &'input str = r"[A-Za-z_][A-Za-z_0-9]*";
